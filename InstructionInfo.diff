//===-- RISCVInstrInfo.td - Target Description for RISCV ---*	//===-- RISCVInstrInfo.td - Target Description for RISCV ---*
//								//
// Part of the LLVM Project, under the Apache License v2.0 wi |	//                     The LLVM Compiler Infrastructure
// See https://llvm.org/LICENSE.txt for license information.  |	//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception    |	// This file is distributed under the University of Illinois 
							      >	// License. See LICENSE.TXT for details.
//								//
//===--------------------------------------------------------	//===--------------------------------------------------------
//								//
// This file describes the RISC-V instructions in TableGen fo	// This file describes the RISC-V instructions in TableGen fo
//								//
//===--------------------------------------------------------	//===--------------------------------------------------------

include "RISCVInstrFormats.td"					include "RISCVInstrFormats.td"

//===--------------------------------------------------------	//===--------------------------------------------------------
// RISC-V specific DAG Nodes.					// RISC-V specific DAG Nodes.
//===--------------------------------------------------------	//===--------------------------------------------------------

def SDT_RISCVCall         : SDTypeProfile<0, -1, [SDTCisVT<0,	def SDT_RISCVCall         : SDTypeProfile<0, -1, [SDTCisVT<0,
def SDT_RISCVCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,	def SDT_RISCVCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
                                            SDTCisVT<1, i32>]	                                            SDTCisVT<1, i32>]
def SDT_RISCVCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>,	def SDT_RISCVCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>,
                                          SDTCisVT<1, i32>]>;	                                          SDTCisVT<1, i32>]>;
def SDT_RISCVSelectCC     : SDTypeProfile<1, 5, [SDTCisSameAs	def SDT_RISCVSelectCC     : SDTypeProfile<1, 5, [SDTCisSameAs
                                                 SDTCisSameAs	                                                 SDTCisSameAs
                                                 SDTCisSameAs	                                                 SDTCisSameAs


def Call         : SDNode<"RISCVISD::CALL", SDT_RISCVCall,	def Call         : SDNode<"RISCVISD::CALL", SDT_RISCVCall,
                          [SDNPHasChain, SDNPOptInGlue, SDNPO	                          [SDNPHasChain, SDNPOptInGlue, SDNPO
                           SDNPVariadic]>;			                           SDNPVariadic]>;
def CallSeqStart : SDNode<"ISD::CALLSEQ_START", SDT_RISCVCall	def CallSeqStart : SDNode<"ISD::CALLSEQ_START", SDT_RISCVCall
                          [SDNPHasChain, SDNPOutGlue]>;		                          [SDNPHasChain, SDNPOutGlue]>;
def CallSeqEnd   : SDNode<"ISD::CALLSEQ_END", SDT_RISCVCallSe	def CallSeqEnd   : SDNode<"ISD::CALLSEQ_END", SDT_RISCVCallSe
                          [SDNPHasChain, SDNPOptInGlue, SDNPO	                          [SDNPHasChain, SDNPOptInGlue, SDNPO
def RetFlag      : SDNode<"RISCVISD::RET_FLAG", SDTNone,	def RetFlag      : SDNode<"RISCVISD::RET_FLAG", SDTNone,
                          [SDNPHasChain, SDNPOptInGlue, SDNPV	                          [SDNPHasChain, SDNPOptInGlue, SDNPV
def URetFlag     : SDNode<"RISCVISD::URET_FLAG", SDTNone,	def URetFlag     : SDNode<"RISCVISD::URET_FLAG", SDTNone,
                          [SDNPHasChain, SDNPOptInGlue]>;	                          [SDNPHasChain, SDNPOptInGlue]>;
def SRetFlag     : SDNode<"RISCVISD::SRET_FLAG", SDTNone,	def SRetFlag     : SDNode<"RISCVISD::SRET_FLAG", SDTNone,
                          [SDNPHasChain, SDNPOptInGlue]>;	                          [SDNPHasChain, SDNPOptInGlue]>;
def MRetFlag     : SDNode<"RISCVISD::MRET_FLAG", SDTNone,	def MRetFlag     : SDNode<"RISCVISD::MRET_FLAG", SDTNone,
                          [SDNPHasChain, SDNPOptInGlue]>;	                          [SDNPHasChain, SDNPOptInGlue]>;
def SelectCC     : SDNode<"RISCVISD::SELECT_CC", SDT_RISCVSel	def SelectCC     : SDNode<"RISCVISD::SELECT_CC", SDT_RISCVSel
                          [SDNPInGlue]>;			                          [SDNPInGlue]>;
def Tail         : SDNode<"RISCVISD::TAIL", SDT_RISCVCall,	def Tail         : SDNode<"RISCVISD::TAIL", SDT_RISCVCall,
                          [SDNPHasChain, SDNPOptInGlue, SDNPO	                          [SDNPHasChain, SDNPOptInGlue, SDNPO
                           SDNPVariadic]>;			                           SDNPVariadic]>;

//===--------------------------------------------------------	//===--------------------------------------------------------
// Operand and SDNode transformation definitions.		// Operand and SDNode transformation definitions.
//===--------------------------------------------------------	//===--------------------------------------------------------

class ImmXLenAsmOperand<string prefix, string suffix = ""> : 	class ImmXLenAsmOperand<string prefix, string suffix = ""> : 
  let Name = prefix # "ImmXLen" # suffix;			  let Name = prefix # "ImmXLen" # suffix;
  let RenderMethod = "addImmOperands";				  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);		  let DiagnosticType = !strconcat("Invalid", Name);
}								}

class ImmAsmOperand<string prefix, int width, string suffix> 	class ImmAsmOperand<string prefix, int width, string suffix> 
  let Name = prefix # "Imm" # width # suffix;			  let Name = prefix # "Imm" # width # suffix;
  let RenderMethod = "addImmOperands";				  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);		  let DiagnosticType = !strconcat("Invalid", Name);
}								}

class SImmAsmOperand<int width, string suffix = "">		class SImmAsmOperand<int width, string suffix = "">
    : ImmAsmOperand<"S", width, suffix> {			    : ImmAsmOperand<"S", width, suffix> {
}								}

class UImmAsmOperand<int width, string suffix = "">		class UImmAsmOperand<int width, string suffix = "">
    : ImmAsmOperand<"U", width, suffix> {			    : ImmAsmOperand<"U", width, suffix> {
}								}

def FenceArg : AsmOperandClass {				def FenceArg : AsmOperandClass {
  let Name = "FenceArg";					  let Name = "FenceArg";
  let RenderMethod = "addFenceArgOperands";			  let RenderMethod = "addFenceArgOperands";
  let DiagnosticType = "InvalidFenceArg";			  let DiagnosticType = "InvalidFenceArg";
}								}

def fencearg : Operand<XLenVT> {				def fencearg : Operand<XLenVT> {
  let ParserMatchClass = FenceArg;				  let ParserMatchClass = FenceArg;
  let PrintMethod = "printFenceArg";				  let PrintMethod = "printFenceArg";
  let DecoderMethod = "decodeUImmOperand<4>";			  let DecoderMethod = "decodeUImmOperand<4>";
}								}

def UImmLog2XLenAsmOperand : AsmOperandClass {			def UImmLog2XLenAsmOperand : AsmOperandClass {
  let Name = "UImmLog2XLen";					  let Name = "UImmLog2XLen";
  let RenderMethod = "addImmOperands";				  let RenderMethod = "addImmOperands";
  let DiagnosticType = "InvalidUImmLog2XLen";			  let DiagnosticType = "InvalidUImmLog2XLen";
}								}

def uimmlog2xlen : Operand<XLenVT>, ImmLeaf<XLenVT, [{		def uimmlog2xlen : Operand<XLenVT>, ImmLeaf<XLenVT, [{
  if (Subtarget->is64Bit())					  if (Subtarget->is64Bit())
    return isUInt<6>(Imm);					    return isUInt<6>(Imm);
  return isUInt<5>(Imm);					  return isUInt<5>(Imm);
}]> {								}]> {
  let ParserMatchClass = UImmLog2XLenAsmOperand;		  let ParserMatchClass = UImmLog2XLenAsmOperand;
  // TODO: should ensure invalid shamt is rejected when decod	  // TODO: should ensure invalid shamt is rejected when decod
  let DecoderMethod = "decodeUImmOperand<6>";			  let DecoderMethod = "decodeUImmOperand<6>";
  let MCOperandPredicate = [{					  let MCOperandPredicate = [{
    int64_t Imm;						    int64_t Imm;
    if (!MCOp.evaluateAsConstantImm(Imm))			    if (!MCOp.evaluateAsConstantImm(Imm))
      return false;						      return false;
    if (STI.getTargetTriple().isArch64Bit())			    if (STI.getTargetTriple().isArch64Bit())
      return  isUInt<6>(Imm);					      return  isUInt<6>(Imm);
    return isUInt<5>(Imm);					    return isUInt<5>(Imm);
  }];								  }];
}								}

def uimm5 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<	def uimm5 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<
  let ParserMatchClass = UImmAsmOperand<5>;			  let ParserMatchClass = UImmAsmOperand<5>;
  let DecoderMethod = "decodeUImmOperand<5>";			  let DecoderMethod = "decodeUImmOperand<5>";
}								}

def simm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<	def simm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<
  let ParserMatchClass = SImmAsmOperand<12>;			  let ParserMatchClass = SImmAsmOperand<12>;
  let EncoderMethod = "getImmOpValue";				  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeSImmOperand<12>";			  let DecoderMethod = "decodeSImmOperand<12>";
  let MCOperandPredicate = [{					  let MCOperandPredicate = [{
    int64_t Imm;						    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))			    if (MCOp.evaluateAsConstantImm(Imm))
      return isInt<12>(Imm);					      return isInt<12>(Imm);
    return MCOp.isBareSymbolRef();				    return MCOp.isBareSymbolRef();
  }];								  }];
}								}

// A 13-bit signed immediate where the least significant bit 	// A 13-bit signed immediate where the least significant bit 
def simm13_lsb0 : Operand<OtherVT> {				def simm13_lsb0 : Operand<OtherVT> {
  let ParserMatchClass = SImmAsmOperand<13, "Lsb0">;		  let ParserMatchClass = SImmAsmOperand<13, "Lsb0">;
  let EncoderMethod = "getImmOpValueAsr1";			  let EncoderMethod = "getImmOpValueAsr1";
  let DecoderMethod = "decodeSImmOperandAndLsl1<13>";		  let DecoderMethod = "decodeSImmOperandAndLsl1<13>";
  let MCOperandPredicate = [{					  let MCOperandPredicate = [{
    int64_t Imm;						    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))			    if (MCOp.evaluateAsConstantImm(Imm))
      return isShiftedInt<12, 1>(Imm);				      return isShiftedInt<12, 1>(Imm);
    return MCOp.isBareSymbolRef();				    return MCOp.isBareSymbolRef();
  }];								  }];
}								}

class UImm20Operand : Operand<XLenVT> {				class UImm20Operand : Operand<XLenVT> {
  let EncoderMethod = "getImmOpValue";				  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<20>";			  let DecoderMethod = "decodeUImmOperand<20>";
  let MCOperandPredicate = [{					  let MCOperandPredicate = [{
    int64_t Imm;						    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))			    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<20>(Imm);					      return isUInt<20>(Imm);
    return MCOp.isBareSymbolRef();				    return MCOp.isBareSymbolRef();
  }];								  }];
}								}

def uimm20_lui : UImm20Operand {				def uimm20_lui : UImm20Operand {
  let ParserMatchClass = UImmAsmOperand<20, "LUI">;		  let ParserMatchClass = UImmAsmOperand<20, "LUI">;
}								}
def uimm20_auipc : UImm20Operand {				def uimm20_auipc : UImm20Operand {
  let ParserMatchClass = UImmAsmOperand<20, "AUIPC">;		  let ParserMatchClass = UImmAsmOperand<20, "AUIPC">;
}								}

def Simm21Lsb0JALAsmOperand : SImmAsmOperand<21, "Lsb0JAL"> {	def Simm21Lsb0JALAsmOperand : SImmAsmOperand<21, "Lsb0JAL"> {
  let ParserMethod = "parseJALOffset";				  let ParserMethod = "parseJALOffset";
}								}

// A 21-bit signed immediate where the least significant bit 	// A 21-bit signed immediate where the least significant bit 
def simm21_lsb0_jal : Operand<OtherVT> {			def simm21_lsb0_jal : Operand<OtherVT> {
  let ParserMatchClass = Simm21Lsb0JALAsmOperand;		  let ParserMatchClass = Simm21Lsb0JALAsmOperand;
  let EncoderMethod = "getImmOpValueAsr1";			  let EncoderMethod = "getImmOpValueAsr1";
  let DecoderMethod = "decodeSImmOperandAndLsl1<21>";		  let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
  let MCOperandPredicate = [{					  let MCOperandPredicate = [{
    int64_t Imm;						    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))			    if (MCOp.evaluateAsConstantImm(Imm))
      return isShiftedInt<20, 1>(Imm);				      return isShiftedInt<20, 1>(Imm);
    return MCOp.isBareSymbolRef();				    return MCOp.isBareSymbolRef();
  }];								  }];
}								}

def BareSymbol : AsmOperandClass {				def BareSymbol : AsmOperandClass {
  let Name = "BareSymbol";					  let Name = "BareSymbol";
  let RenderMethod = "addImmOperands";				  let RenderMethod = "addImmOperands";
  let DiagnosticType = "InvalidBareSymbol";			  let DiagnosticType = "InvalidBareSymbol";
  let ParserMethod = "parseBareSymbol";				  let ParserMethod = "parseBareSymbol";
}								}

// A bare symbol.						// A bare symbol.
def bare_symbol : Operand<XLenVT> {				def bare_symbol : Operand<XLenVT> {
  let ParserMatchClass = BareSymbol;				  let ParserMatchClass = BareSymbol;
}								}

def CSRSystemRegister : AsmOperandClass {			def CSRSystemRegister : AsmOperandClass {
  let Name = "CSRSystemRegister";				  let Name = "CSRSystemRegister";
  let ParserMethod = "parseCSRSystemRegister";			  let ParserMethod = "parseCSRSystemRegister";
  let DiagnosticType = "InvalidCSRSystemRegister";		  let DiagnosticType = "InvalidCSRSystemRegister";
}								}

def csr_sysreg : Operand<XLenVT> {				def csr_sysreg : Operand<XLenVT> {
  let ParserMatchClass = CSRSystemRegister;			  let ParserMatchClass = CSRSystemRegister;
  let PrintMethod = "printCSRSystemRegister";			  let PrintMethod = "printCSRSystemRegister";
  let DecoderMethod = "decodeUImmOperand<12>";			  let DecoderMethod = "decodeUImmOperand<12>";
}								}

// A parameterized register class alternative to i32imm/i64im	// A parameterized register class alternative to i32imm/i64im
def ixlenimm : Operand<XLenVT>;					def ixlenimm : Operand<XLenVT>;

def ixlenimm_li : Operand<XLenVT> {				def ixlenimm_li : Operand<XLenVT> {
  let ParserMatchClass = ImmXLenAsmOperand<"", "LI">;		  let ParserMatchClass = ImmXLenAsmOperand<"", "LI">;
}								}

// Standalone (codegen-only) immleaf patterns.			// Standalone (codegen-only) immleaf patterns.
def simm32     : ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;	def simm32     : ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;
def simm32hi20 : ImmLeaf<XLenVT, [{return isShiftedInt<20, 12	def simm32hi20 : ImmLeaf<XLenVT, [{return isShiftedInt<20, 12
// A mask value that won't affect significant shift bits.	// A mask value that won't affect significant shift bits.
def immbottomxlenset : ImmLeaf<XLenVT, [{			def immbottomxlenset : ImmLeaf<XLenVT, [{
  if (Subtarget->is64Bit())					  if (Subtarget->is64Bit())
    return countTrailingOnes<uint64_t>(Imm) >= 6;		    return countTrailingOnes<uint64_t>(Imm) >= 6;
  return countTrailingOnes<uint64_t>(Imm) >= 5;			  return countTrailingOnes<uint64_t>(Imm) >= 5;
}]>;								}]>;

// Addressing modes.						// Addressing modes.
// Necessary because a frameindex can't be matched directly i	// Necessary because a frameindex can't be matched directly i
def AddrFI : ComplexPattern<iPTR, 1, "SelectAddrFI", [framein	def AddrFI : ComplexPattern<iPTR, 1, "SelectAddrFI", [framein

// Extract least significant 12 bits from an immediate value 	// Extract least significant 12 bits from an immediate value 
// them.							// them.
def LO12Sext : SDNodeXForm<imm, [{				def LO12Sext : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(SignExtend64<12>(N->getZEx	  return CurDAG->getTargetConstant(SignExtend64<12>(N->getZEx
                                   SDLoc(N), N->getValueType(	                                   SDLoc(N), N->getValueType(
}]>;								}]>;

// Extract the most significant 20 bits from an immediate val	// Extract the most significant 20 bits from an immediate val
// 11 is 1, to compensate for the low 12 bits in the matching	// 11 is 1, to compensate for the low 12 bits in the matching
// or ld/st being negative.					// or ld/st being negative.
def HI20 : SDNodeXForm<imm, [{					def HI20 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(((N->getZExtValue()+0x800)	  return CurDAG->getTargetConstant(((N->getZExtValue()+0x800)
                                   SDLoc(N), N->getValueType(	                                   SDLoc(N), N->getValueType(
}]>;								}]>;

//===--------------------------------------------------------	//===--------------------------------------------------------
// Instruction Class Templates					// Instruction Class Templates
//===--------------------------------------------------------	//===--------------------------------------------------------

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class BranchCC_rri<bits<3> funct3, string opcodestr>		class BranchCC_rri<bits<3> funct3, string opcodestr>
    : RVInstB<funct3, OPC_BRANCH, (outs),			    : RVInstB<funct3, OPC_BRANCH, (outs),
              (ins GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12),	              (ins GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12),
              opcodestr, "$rs1, $rs2, $imm12"> {		              opcodestr, "$rs1, $rs2, $imm12"> {
  let isBranch = 1;						  let isBranch = 1;
  let isTerminator = 1;						  let isTerminator = 1;
}								}

let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
class Load_ri<bits<3> funct3, string opcodestr>			class Load_ri<bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_LOAD, (outs GPR:$rd), (ins GPR:$rs1	    : RVInstI<funct3, OPC_LOAD, (outs GPR:$rd), (ins GPR:$rs1
              opcodestr, "$rd, ${imm12}(${rs1})">;		              opcodestr, "$rd, ${imm12}(${rs1})">;

// Operands for stores are in the order srcreg, base, offset 	// Operands for stores are in the order srcreg, base, offset 
// reflecting the order these fields are specified in the ins	// reflecting the order these fields are specified in the ins
// encoding.							// encoding.
let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
class Store_rri<bits<3> funct3, string opcodestr>		class Store_rri<bits<3> funct3, string opcodestr>
    : RVInstS<funct3, OPC_STORE, (outs),			    : RVInstS<funct3, OPC_STORE, (outs),
              (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),		              (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
              opcodestr, "$rs2, ${imm12}(${rs1})">;		              opcodestr, "$rs2, ${imm12}(${rs1})">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class ALU_ri<bits<3> funct3, string opcodestr>			class ALU_ri<bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_OP_IMM, (outs GPR:$rd), (ins GPR:$r	    : RVInstI<funct3, OPC_OP_IMM, (outs GPR:$rd), (ins GPR:$r
              opcodestr, "$rd, $rs1, $imm12">;			              opcodestr, "$rd, $rs1, $imm12">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Shift_ri<bit arithshift, bits<3> funct3, string opcodes	class Shift_ri<bit arithshift, bits<3> funct3, string opcodes
    : RVInstIShift<arithshift, funct3, OPC_OP_IMM, (outs GPR:	    : RVInstIShift<arithshift, funct3, OPC_OP_IMM, (outs GPR:
                   (ins GPR:$rs1, uimmlog2xlen:$shamt), opcod	                   (ins GPR:$rs1, uimmlog2xlen:$shamt), opcod
                   "$rd, $rs1, $shamt">;			                   "$rd, $rs1, $shamt">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class ALU_rr<bits<7> funct7, bits<3> funct3, string opcodestr	class ALU_rr<bits<7> funct7, bits<3> funct3, string opcodestr
    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GP	    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GP
              opcodestr, "$rd, $rs1, $rs2">;			              opcodestr, "$rd, $rs1, $rs2">;

							      >	let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
							      >	class Load_drr<bits<7> funct7, bits<3> funct3, string opcodes
							      >	    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GP
							      >	              opcodestr, "$rd, $rs1, $rs2">;
							      >
							      >	let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
							      >	class Store_drrr<bits<7> funct7, bits<3> funct3, string opcod
							      >	    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GP
							      >	              opcodestr, "$rd, $rs1, $rs2">;
							      >
let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
class CSR_ir<bits<3> funct3, string opcodestr>			class CSR_ir<bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd), (ins csr_sy	    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd), (ins csr_sy
              opcodestr, "$rd, $imm12, $rs1">;			              opcodestr, "$rd, $imm12, $rs1">;

let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
class CSR_ii<bits<3> funct3, string opcodestr>			class CSR_ii<bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd),		    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd),
              (ins csr_sysreg:$imm12, uimm5:$rs1),		              (ins csr_sysreg:$imm12, uimm5:$rs1),
              opcodestr, "$rd, $imm12, $rs1">;			              opcodestr, "$rd, $imm12, $rs1">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class ShiftW_ri<bit arithshift, bits<3> funct3, string opcode	class ShiftW_ri<bit arithshift, bits<3> funct3, string opcode
    : RVInstIShiftW<arithshift, funct3, OPC_OP_IMM_32, (outs 	    : RVInstIShiftW<arithshift, funct3, OPC_OP_IMM_32, (outs 
                    (ins GPR:$rs1, uimm5:$shamt), opcodestr,	                    (ins GPR:$rs1, uimm5:$shamt), opcodestr,
                    "$rd, $rs1, $shamt">;			                    "$rd, $rs1, $shamt">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class ALUW_rr<bits<7> funct7, bits<3> funct3, string opcodest	class ALUW_rr<bits<7> funct7, bits<3> funct3, string opcodest
    : RVInstR<funct7, funct3, OPC_OP_32, (outs GPR:$rd),	    : RVInstR<funct7, funct3, OPC_OP_32, (outs GPR:$rd),
              (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1	              (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1

let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
class Priv<string opcodestr, bits<7> funct7>			class Priv<string opcodestr, bits<7> funct7>
    : RVInstR<funct7, 0b000, OPC_SYSTEM, (outs), (ins GPR:$rs	    : RVInstR<funct7, 0b000, OPC_SYSTEM, (outs), (ins GPR:$rs
              opcodestr, "">;					              opcodestr, "">;

//===--------------------------------------------------------	//===--------------------------------------------------------
// Instructions							// Instructions
//===--------------------------------------------------------	//===--------------------------------------------------------

let hasSideEffects = 0, isReMaterializable = 1, mayLoad = 0, 	let hasSideEffects = 0, isReMaterializable = 1, mayLoad = 0, 
def LUI : RVInstU<OPC_LUI, (outs GPR:$rd), (ins uimm20_lui:$i	def LUI : RVInstU<OPC_LUI, (outs GPR:$rd), (ins uimm20_lui:$i
                  "lui", "$rd, $imm20">;			                  "lui", "$rd, $imm20">;

def AUIPC : RVInstU<OPC_AUIPC, (outs GPR:$rd), (ins uimm20_au	def AUIPC : RVInstU<OPC_AUIPC, (outs GPR:$rd), (ins uimm20_au
                    "auipc", "$rd, $imm20">;			                    "auipc", "$rd, $imm20">;

let isCall = 1 in						let isCall = 1 in
def JAL : RVInstJ<OPC_JAL, (outs GPR:$rd), (ins simm21_lsb0_j	def JAL : RVInstJ<OPC_JAL, (outs GPR:$rd), (ins simm21_lsb0_j
                  "jal", "$rd, $imm20">;			                  "jal", "$rd, $imm20">;

let isCall = 1 in						let isCall = 1 in
def JALR : RVInstI<0b000, OPC_JALR, (outs GPR:$rd),		def JALR : RVInstI<0b000, OPC_JALR, (outs GPR:$rd),
                   (ins GPR:$rs1, simm12:$imm12),		                   (ins GPR:$rs1, simm12:$imm12),
                   "jalr", "$rd, $rs1, $imm12">;		                   "jalr", "$rd, $rs1, $imm12">;
} // hasSideEffects = 0, mayLoad = 0, mayStore = 0		} // hasSideEffects = 0, mayLoad = 0, mayStore = 0

def BEQ  : BranchCC_rri<0b000, "beq">;				def BEQ  : BranchCC_rri<0b000, "beq">;
def BNE  : BranchCC_rri<0b001, "bne">;				def BNE  : BranchCC_rri<0b001, "bne">;
def BLT  : BranchCC_rri<0b100, "blt">;				def BLT  : BranchCC_rri<0b100, "blt">;
def BGE  : BranchCC_rri<0b101, "bge">;				def BGE  : BranchCC_rri<0b101, "bge">;
def BLTU : BranchCC_rri<0b110, "bltu">;				def BLTU : BranchCC_rri<0b110, "bltu">;
def BGEU : BranchCC_rri<0b111, "bgeu">;				def BGEU : BranchCC_rri<0b111, "bgeu">;

def LB  : Load_ri<0b000, "lb">;					def LB  : Load_ri<0b000, "lb">;
def LH  : Load_ri<0b001, "lh">;					def LH  : Load_ri<0b001, "lh">;
def LW  : Load_ri<0b010, "lw">;					def LW  : Load_ri<0b010, "lw">;
def LBU : Load_ri<0b100, "lbu">;				def LBU : Load_ri<0b100, "lbu">;
def LHU : Load_ri<0b101, "lhu">;				def LHU : Load_ri<0b101, "lhu">;

							      >	def LDW : Load_drr<0b0010000, 0b000, "ldw">;
							      >
def SB : Store_rri<0b000, "sb">;				def SB : Store_rri<0b000, "sb">;
def SH : Store_rri<0b001, "sh">;				def SH : Store_rri<0b001, "sh">;
def SW : Store_rri<0b010, "sw">;				def SW : Store_rri<0b010, "sw">;

							      >	def SDW : Store_drrr<0b0010000, 0b001, "sdw">;
							      >
// ADDI isn't always rematerializable, but isReMaterializable	// ADDI isn't always rematerializable, but isReMaterializable
// a hint which is verified in isReallyTriviallyReMaterializa	// a hint which is verified in isReallyTriviallyReMaterializa
let isReMaterializable = 1 in					let isReMaterializable = 1 in
def ADDI  : ALU_ri<0b000, "addi">;				def ADDI  : ALU_ri<0b000, "addi">;

def SLTI  : ALU_ri<0b010, "slti">;				def SLTI  : ALU_ri<0b010, "slti">;
def SLTIU : ALU_ri<0b011, "sltiu">;				def SLTIU : ALU_ri<0b011, "sltiu">;
def XORI  : ALU_ri<0b100, "xori">;				def XORI  : ALU_ri<0b100, "xori">;
def ORI   : ALU_ri<0b110, "ori">;				def ORI   : ALU_ri<0b110, "ori">;
def ANDI  : ALU_ri<0b111, "andi">;				def ANDI  : ALU_ri<0b111, "andi">;

def SLLI : Shift_ri<0, 0b001, "slli">;				def SLLI : Shift_ri<0, 0b001, "slli">;
def SRLI : Shift_ri<0, 0b101, "srli">;				def SRLI : Shift_ri<0, 0b101, "srli">;
def SRAI : Shift_ri<1, 0b101, "srai">;				def SRAI : Shift_ri<1, 0b101, "srai">;

def ADD  : ALU_rr<0b0000000, 0b000, "add">;			def ADD  : ALU_rr<0b0000000, 0b000, "add">;
def SUB  : ALU_rr<0b0100000, 0b000, "sub">;			def SUB  : ALU_rr<0b0100000, 0b000, "sub">;
def SLL  : ALU_rr<0b0000000, 0b001, "sll">;			def SLL  : ALU_rr<0b0000000, 0b001, "sll">;
def SLT  : ALU_rr<0b0000000, 0b010, "slt">;			def SLT  : ALU_rr<0b0000000, 0b010, "slt">;
def SLTU : ALU_rr<0b0000000, 0b011, "sltu">;			def SLTU : ALU_rr<0b0000000, 0b011, "sltu">;
def XOR  : ALU_rr<0b0000000, 0b100, "xor">;			def XOR  : ALU_rr<0b0000000, 0b100, "xor">;
def SRL  : ALU_rr<0b0000000, 0b101, "srl">;			def SRL  : ALU_rr<0b0000000, 0b101, "srl">;
def SRA  : ALU_rr<0b0100000, 0b101, "sra">;			def SRA  : ALU_rr<0b0100000, 0b101, "sra">;
def OR   : ALU_rr<0b0000000, 0b110, "or">;			def OR   : ALU_rr<0b0000000, 0b110, "or">;
def AND  : ALU_rr<0b0000000, 0b111, "and">;			def AND  : ALU_rr<0b0000000, 0b111, "and">;

let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {		let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
def FENCE : RVInstI<0b000, OPC_MISC_MEM, (outs),		def FENCE : RVInstI<0b000, OPC_MISC_MEM, (outs),
                    (ins fencearg:$pred, fencearg:$succ),	                    (ins fencearg:$pred, fencearg:$succ),
                    "fence", "$pred, $succ"> {			                    "fence", "$pred, $succ"> {
  bits<4> pred;							  bits<4> pred;
  bits<4> succ;							  bits<4> succ;

  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = {0b0000,pred,succ};				  let imm12 = {0b0000,pred,succ};
}								}

def FENCE_TSO : RVInstI<0b000, OPC_MISC_MEM, (outs), (ins), "	def FENCE_TSO : RVInstI<0b000, OPC_MISC_MEM, (outs), (ins), "
  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = {0b1000,0b0011,0b0011};				  let imm12 = {0b1000,0b0011,0b0011};
}								}

def FENCE_I : RVInstI<0b001, OPC_MISC_MEM, (outs), (ins), "fe	def FENCE_I : RVInstI<0b001, OPC_MISC_MEM, (outs), (ins), "fe
  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = 0;						  let imm12 = 0;
}								}

def ECALL : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ecall"	def ECALL : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ecall"
  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = 0;						  let imm12 = 0;
}								}

def EBREAK : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ebrea	def EBREAK : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ebrea
  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = 1;						  let imm12 = 1;
}								}

// This is a de facto standard (as set by GNU binutils) 32-bi	// This is a de facto standard (as set by GNU binutils) 32-bi
// instruction (i.e., it should always trap, if your implemen	// instruction (i.e., it should always trap, if your implemen
// instruction traps).						// instruction traps).
def UNIMP : RVInstI<0b001, OPC_SYSTEM, (outs), (ins), "unimp"	def UNIMP : RVInstI<0b001, OPC_SYSTEM, (outs), (ins), "unimp"
  let rs1 = 0;							  let rs1 = 0;
  let rd = 0;							  let rd = 0;
  let imm12 = 0b110000000000;					  let imm12 = 0b110000000000;
}								}
} // hasSideEffects = 1, mayLoad = 0, mayStore = 0		} // hasSideEffects = 1, mayLoad = 0, mayStore = 0

def CSRRW : CSR_ir<0b001, "csrrw">;				def CSRRW : CSR_ir<0b001, "csrrw">;
def CSRRS : CSR_ir<0b010, "csrrs">;				def CSRRS : CSR_ir<0b010, "csrrs">;
def CSRRC : CSR_ir<0b011, "csrrc">;				def CSRRC : CSR_ir<0b011, "csrrc">;

def CSRRWI : CSR_ii<0b101, "csrrwi">;				def CSRRWI : CSR_ii<0b101, "csrrwi">;
def CSRRSI : CSR_ii<0b110, "csrrsi">;				def CSRRSI : CSR_ii<0b110, "csrrsi">;
def CSRRCI : CSR_ii<0b111, "csrrci">;				def CSRRCI : CSR_ii<0b111, "csrrci">;

							      >
/// RV64I instructions						/// RV64I instructions

let Predicates = [IsRV64] in {					let Predicates = [IsRV64] in {
def LWU   : Load_ri<0b110, "lwu">;				def LWU   : Load_ri<0b110, "lwu">;
def LD    : Load_ri<0b011, "ld">;				def LD    : Load_ri<0b011, "ld">;
def SD    : Store_rri<0b011, "sd">;				def SD    : Store_rri<0b011, "sd">;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
def ADDIW : RVInstI<0b000, OPC_OP_IMM_32, (outs GPR:$rd),	def ADDIW : RVInstI<0b000, OPC_OP_IMM_32, (outs GPR:$rd),
                    (ins GPR:$rs1, simm12:$imm12),		                    (ins GPR:$rs1, simm12:$imm12),
                    "addiw", "$rd, $rs1, $imm12">;		                    "addiw", "$rd, $rs1, $imm12">;

def SLLIW : ShiftW_ri<0, 0b001, "slliw">;			def SLLIW : ShiftW_ri<0, 0b001, "slliw">;
def SRLIW : ShiftW_ri<0, 0b101, "srliw">;			def SRLIW : ShiftW_ri<0, 0b101, "srliw">;
def SRAIW : ShiftW_ri<1, 0b101, "sraiw">;			def SRAIW : ShiftW_ri<1, 0b101, "sraiw">;

def ADDW  : ALUW_rr<0b0000000, 0b000, "addw">;			def ADDW  : ALUW_rr<0b0000000, 0b000, "addw">;
def SUBW  : ALUW_rr<0b0100000, 0b000, "subw">;			def SUBW  : ALUW_rr<0b0100000, 0b000, "subw">;
def SLLW  : ALUW_rr<0b0000000, 0b001, "sllw">;			def SLLW  : ALUW_rr<0b0000000, 0b001, "sllw">;
def SRLW  : ALUW_rr<0b0000000, 0b101, "srlw">;			def SRLW  : ALUW_rr<0b0000000, 0b101, "srlw">;
def SRAW  : ALUW_rr<0b0100000, 0b101, "sraw">;			def SRAW  : ALUW_rr<0b0100000, 0b101, "sraw">;
} // Predicates = [IsRV64]					} // Predicates = [IsRV64]

//===--------------------------------------------------------	//===--------------------------------------------------------
// Privileged instructions					// Privileged instructions
//===--------------------------------------------------------	//===--------------------------------------------------------

let isBarrier = 1, isReturn = 1, isTerminator = 1 in {		let isBarrier = 1, isReturn = 1, isTerminator = 1 in {
def URET : Priv<"uret", 0b0000000> {				def URET : Priv<"uret", 0b0000000> {
  let rd = 0;							  let rd = 0;
  let rs1 = 0;							  let rs1 = 0;
  let rs2 = 0b00010;						  let rs2 = 0b00010;
}								}

def SRET : Priv<"sret", 0b0001000> {				def SRET : Priv<"sret", 0b0001000> {
  let rd = 0;							  let rd = 0;
  let rs1 = 0;							  let rs1 = 0;
  let rs2 = 0b00010;						  let rs2 = 0b00010;
}								}

def MRET : Priv<"mret", 0b0011000> {				def MRET : Priv<"mret", 0b0011000> {
  let rd = 0;							  let rd = 0;
  let rs1 = 0;							  let rs1 = 0;
  let rs2 = 0b00010;						  let rs2 = 0b00010;
}								}
} // isBarrier = 1, isReturn = 1, isTerminator = 1		} // isBarrier = 1, isReturn = 1, isTerminator = 1

def WFI : Priv<"wfi", 0b0001000> {				def WFI : Priv<"wfi", 0b0001000> {
  let rd = 0;							  let rd = 0;
  let rs1 = 0;							  let rs1 = 0;
  let rs2 = 0b00101;						  let rs2 = 0b00101;
}								}

let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in		let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
def SFENCE_VMA : RVInstR<0b0001001, 0b000, OPC_SYSTEM, (outs)	def SFENCE_VMA : RVInstR<0b0001001, 0b000, OPC_SYSTEM, (outs)
                         (ins GPR:$rs1, GPR:$rs2),		                         (ins GPR:$rs1, GPR:$rs2),
                         "sfence.vma", "$rs1, $rs2"> {		                         "sfence.vma", "$rs1, $rs2"> {
  let rd = 0;							  let rd = 0;
}								}

//===--------------------------------------------------------	//===--------------------------------------------------------
// Assembler Pseudo Instructions (User-Level ISA, Version 2.2	// Assembler Pseudo Instructions (User-Level ISA, Version 2.2
//===--------------------------------------------------------	//===--------------------------------------------------------

// TODO la							// TODO la
// TODO lb lh lw						// TODO lb lh lw
// TODO RV64I: ld						// TODO RV64I: ld
// TODO sb sh sw						// TODO sb sh sw
// TODO RV64I: sd						// TODO RV64I: sd

def : InstAlias<"nop",           (ADDI      X0,      X0,     	def : InstAlias<"nop",           (ADDI      X0,      X0,     

// Note that the size is 32 because up to 8 32-bit instructio	// Note that the size is 32 because up to 8 32-bit instructio
// generate an arbitrary 64-bit immediate. However, the size 	// generate an arbitrary 64-bit immediate. However, the size 
// matter since PseudoLI is currently only used in the AsmPar	// matter since PseudoLI is currently only used in the AsmPar
// expanded to real instructions immediately.			// expanded to real instructions immediately.
let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Size = 32,	let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Size = 32,
    isCodeGenOnly = 0, isAsmParserOnly = 1 in			    isCodeGenOnly = 0, isAsmParserOnly = 1 in
def PseudoLI : Pseudo<(outs GPR:$rd), (ins ixlenimm_li:$imm),	def PseudoLI : Pseudo<(outs GPR:$rd), (ins ixlenimm_li:$imm),
                      "li", "$rd, $imm">;			                      "li", "$rd, $imm">;

def : InstAlias<"mv $rd, $rs",   (ADDI GPR:$rd, GPR:$rs,     	def : InstAlias<"mv $rd, $rs",   (ADDI GPR:$rd, GPR:$rs,     
def : InstAlias<"not $rd, $rs",  (XORI GPR:$rd, GPR:$rs,     	def : InstAlias<"not $rd, $rs",  (XORI GPR:$rd, GPR:$rs,     
def : InstAlias<"neg $rd, $rs",  (SUB  GPR:$rd,      X0, GPR:	def : InstAlias<"neg $rd, $rs",  (SUB  GPR:$rd,      X0, GPR:

let Predicates = [IsRV64] in {					let Predicates = [IsRV64] in {
def : InstAlias<"negw $rd, $rs",   (SUBW  GPR:$rd,      X0, G	def : InstAlias<"negw $rd, $rs",   (SUBW  GPR:$rd,      X0, G
def : InstAlias<"sext.w $rd, $rs", (ADDIW GPR:$rd, GPR:$rs,  	def : InstAlias<"sext.w $rd, $rs", (ADDIW GPR:$rd, GPR:$rs,  
} // Predicates = [IsRV64]					} // Predicates = [IsRV64]

def : InstAlias<"seqz $rd, $rs", (SLTIU GPR:$rd, GPR:$rs,    	def : InstAlias<"seqz $rd, $rs", (SLTIU GPR:$rd, GPR:$rs,    
def : InstAlias<"snez $rd, $rs", (SLTU  GPR:$rd,      X0, GPR	def : InstAlias<"snez $rd, $rs", (SLTU  GPR:$rd,      X0, GPR
def : InstAlias<"sltz $rd, $rs", (SLT   GPR:$rd, GPR:$rs,    	def : InstAlias<"sltz $rd, $rs", (SLT   GPR:$rd, GPR:$rs,    
def : InstAlias<"sgtz $rd, $rs", (SLT   GPR:$rd,      X0, GPR	def : InstAlias<"sgtz $rd, $rs", (SLT   GPR:$rd,      X0, GPR

// sgt/sgtu are recognised by the GNU assembler but the canon	// sgt/sgtu are recognised by the GNU assembler but the canon
// form will always be printed. Therefore, set a zero weight.	// form will always be printed. Therefore, set a zero weight.
def : InstAlias<"sgt $rd, $rs, $rt", (SLT GPR:$rd, GPR:$rt, G	def : InstAlias<"sgt $rd, $rs, $rt", (SLT GPR:$rd, GPR:$rt, G
def : InstAlias<"sgtu $rd, $rs, $rt", (SLTU GPR:$rd, GPR:$rt,	def : InstAlias<"sgtu $rd, $rs, $rt", (SLTU GPR:$rd, GPR:$rt,

def : InstAlias<"beqz $rs, $offset",				def : InstAlias<"beqz $rs, $offset",
                (BEQ GPR:$rs,      X0, simm13_lsb0:$offset)>;	                (BEQ GPR:$rs,      X0, simm13_lsb0:$offset)>;
def : InstAlias<"bnez $rs, $offset",				def : InstAlias<"bnez $rs, $offset",
                (BNE GPR:$rs,      X0, simm13_lsb0:$offset)>;	                (BNE GPR:$rs,      X0, simm13_lsb0:$offset)>;
def : InstAlias<"blez $rs, $offset",				def : InstAlias<"blez $rs, $offset",
                (BGE      X0, GPR:$rs, simm13_lsb0:$offset)>;	                (BGE      X0, GPR:$rs, simm13_lsb0:$offset)>;
def : InstAlias<"bgez $rs, $offset",				def : InstAlias<"bgez $rs, $offset",
                (BGE GPR:$rs,      X0, simm13_lsb0:$offset)>;	                (BGE GPR:$rs,      X0, simm13_lsb0:$offset)>;
def : InstAlias<"bltz $rs, $offset",				def : InstAlias<"bltz $rs, $offset",
                (BLT GPR:$rs,      X0, simm13_lsb0:$offset)>;	                (BLT GPR:$rs,      X0, simm13_lsb0:$offset)>;
def : InstAlias<"bgtz $rs, $offset",				def : InstAlias<"bgtz $rs, $offset",
                (BLT      X0, GPR:$rs, simm13_lsb0:$offset)>;	                (BLT      X0, GPR:$rs, simm13_lsb0:$offset)>;

// Always output the canonical mnemonic for the pseudo branch	// Always output the canonical mnemonic for the pseudo branch
// The GNU tools emit the canonical mnemonic for the branch p	// The GNU tools emit the canonical mnemonic for the branch p
// as well (e.g. "bgt" will be recognised by the assembler bu	// as well (e.g. "bgt" will be recognised by the assembler bu
// objdump). Match this behaviour by setting a zero weight.	// objdump). Match this behaviour by setting a zero weight.
def : InstAlias<"bgt $rs, $rt, $offset",			def : InstAlias<"bgt $rs, $rt, $offset",
                (BLT  GPR:$rt, GPR:$rs, simm13_lsb0:$offset),	                (BLT  GPR:$rt, GPR:$rs, simm13_lsb0:$offset),
def : InstAlias<"ble $rs, $rt, $offset",			def : InstAlias<"ble $rs, $rt, $offset",
                (BGE  GPR:$rt, GPR:$rs, simm13_lsb0:$offset),	                (BGE  GPR:$rt, GPR:$rs, simm13_lsb0:$offset),
def : InstAlias<"bgtu $rs, $rt, $offset",			def : InstAlias<"bgtu $rs, $rt, $offset",
                (BLTU GPR:$rt, GPR:$rs, simm13_lsb0:$offset),	                (BLTU GPR:$rt, GPR:$rs, simm13_lsb0:$offset),
def : InstAlias<"bleu $rs, $rt, $offset",			def : InstAlias<"bleu $rs, $rt, $offset",
                (BGEU GPR:$rt, GPR:$rs, simm13_lsb0:$offset),	                (BGEU GPR:$rt, GPR:$rs, simm13_lsb0:$offset),

// "ret" has more weight since "ret" and "jr" alias the same 	// "ret" has more weight since "ret" and "jr" alias the same 
def : InstAlias<"j $offset",   (JAL  X0, simm21_lsb0_jal:$off	def : InstAlias<"j $offset",   (JAL  X0, simm21_lsb0_jal:$off
def : InstAlias<"jal $offset", (JAL  X1, simm21_lsb0_jal:$off	def : InstAlias<"jal $offset", (JAL  X1, simm21_lsb0_jal:$off
def : InstAlias<"jr $rs",      (JALR X0, GPR:$rs, 0)>;		def : InstAlias<"jr $rs",      (JALR X0, GPR:$rs, 0)>;
def : InstAlias<"jalr $rs",    (JALR X1, GPR:$rs, 0)>;		def : InstAlias<"jalr $rs",    (JALR X1, GPR:$rs, 0)>;
def : InstAlias<"ret",         (JALR X0,      X1, 0), 2>;	def : InstAlias<"ret",         (JALR X0,      X1, 0), 2>;
// TODO call							// TODO call
// TODO tail							// TODO tail

def : InstAlias<"fence", (FENCE 0xF, 0xF)>; // 0xF == iorw	def : InstAlias<"fence", (FENCE 0xF, 0xF)>; // 0xF == iorw

// CSR Addresses: 0xC00 == cycle,  0xC01 == time,  0xC02 == i	// CSR Addresses: 0xC00 == cycle,  0xC01 == time,  0xC02 == i
//                0xC80 == cycleh, 0xC81 == timeh, 0xC82 == i	//                0xC80 == cycleh, 0xC81 == timeh, 0xC82 == i
def : InstAlias<"rdinstret $rd", (CSRRS GPR:$rd, 0xC02, X0)>;	def : InstAlias<"rdinstret $rd", (CSRRS GPR:$rd, 0xC02, X0)>;
def : InstAlias<"rdcycle $rd",   (CSRRS GPR:$rd, 0xC00, X0)>;	def : InstAlias<"rdcycle $rd",   (CSRRS GPR:$rd, 0xC00, X0)>;
def : InstAlias<"rdtime $rd",    (CSRRS GPR:$rd, 0xC01, X0)>;	def : InstAlias<"rdtime $rd",    (CSRRS GPR:$rd, 0xC01, X0)>;

let Predicates = [IsRV32] in {					let Predicates = [IsRV32] in {
def : InstAlias<"rdinstreth $rd", (CSRRS GPR:$rd, 0xC82, X0)>	def : InstAlias<"rdinstreth $rd", (CSRRS GPR:$rd, 0xC82, X0)>
def : InstAlias<"rdcycleh $rd",   (CSRRS GPR:$rd, 0xC80, X0)>	def : InstAlias<"rdcycleh $rd",   (CSRRS GPR:$rd, 0xC80, X0)>
def : InstAlias<"rdtimeh $rd",    (CSRRS GPR:$rd, 0xC81, X0)>	def : InstAlias<"rdtimeh $rd",    (CSRRS GPR:$rd, 0xC81, X0)>
} // Predicates = [IsRV32]					} // Predicates = [IsRV32]

def : InstAlias<"csrr $rd, $csr", (CSRRS GPR:$rd, csr_sysreg:	def : InstAlias<"csrr $rd, $csr", (CSRRS GPR:$rd, csr_sysreg:
def : InstAlias<"csrw $csr, $rs", (CSRRW      X0, csr_sysreg:	def : InstAlias<"csrw $csr, $rs", (CSRRW      X0, csr_sysreg:
def : InstAlias<"csrs $csr, $rs", (CSRRS      X0, csr_sysreg:	def : InstAlias<"csrs $csr, $rs", (CSRRS      X0, csr_sysreg:
def : InstAlias<"csrc $csr, $rs", (CSRRC      X0, csr_sysreg:	def : InstAlias<"csrc $csr, $rs", (CSRRC      X0, csr_sysreg:

def : InstAlias<"csrwi $csr, $imm", (CSRRWI X0, csr_sysreg:$c	def : InstAlias<"csrwi $csr, $imm", (CSRRWI X0, csr_sysreg:$c
def : InstAlias<"csrsi $csr, $imm", (CSRRSI X0, csr_sysreg:$c	def : InstAlias<"csrsi $csr, $imm", (CSRRSI X0, csr_sysreg:$c
def : InstAlias<"csrci $csr, $imm", (CSRRCI X0, csr_sysreg:$c	def : InstAlias<"csrci $csr, $imm", (CSRRCI X0, csr_sysreg:$c

let EmitPriority = 0 in {					let EmitPriority = 0 in {
def : InstAlias<"csrw $csr, $imm", (CSRRWI X0, csr_sysreg:$cs	def : InstAlias<"csrw $csr, $imm", (CSRRWI X0, csr_sysreg:$cs
def : InstAlias<"csrs $csr, $imm", (CSRRSI X0, csr_sysreg:$cs	def : InstAlias<"csrs $csr, $imm", (CSRRSI X0, csr_sysreg:$cs
def : InstAlias<"csrc $csr, $imm", (CSRRCI X0, csr_sysreg:$cs	def : InstAlias<"csrc $csr, $imm", (CSRRCI X0, csr_sysreg:$cs

def : InstAlias<"csrrw $rd, $csr, $imm", (CSRRWI GPR:$rd, csr	def : InstAlias<"csrrw $rd, $csr, $imm", (CSRRWI GPR:$rd, csr
def : InstAlias<"csrrs $rd, $csr, $imm", (CSRRSI GPR:$rd, csr	def : InstAlias<"csrrs $rd, $csr, $imm", (CSRRSI GPR:$rd, csr
def : InstAlias<"csrrc $rd, $csr, $imm", (CSRRCI GPR:$rd, csr	def : InstAlias<"csrrc $rd, $csr, $imm", (CSRRCI GPR:$rd, csr
}								}

def : InstAlias<"sfence.vma",     (SFENCE_VMA      X0, X0)>;	def : InstAlias<"sfence.vma",     (SFENCE_VMA      X0, X0)>;
def : InstAlias<"sfence.vma $rs", (SFENCE_VMA GPR:$rs, X0)>;	def : InstAlias<"sfence.vma $rs", (SFENCE_VMA GPR:$rs, X0)>;

let EmitPriority = 0 in {					let EmitPriority = 0 in {
def : InstAlias<"add $rd, $rs1, $imm12",			def : InstAlias<"add $rd, $rs1, $imm12",
                (ADDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (ADDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"and $rd, $rs1, $imm12",			def : InstAlias<"and $rd, $rs1, $imm12",
                (ANDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (ANDI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"xor $rd, $rs1, $imm12",			def : InstAlias<"xor $rd, $rs1, $imm12",
                (XORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (XORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"or $rd, $rs1, $imm12",				def : InstAlias<"or $rd, $rs1, $imm12",
                (ORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (ORI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"sll $rd, $rs1, $shamt",			def : InstAlias<"sll $rd, $rs1, $shamt",
                (SLLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt	                (SLLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt
def : InstAlias<"srl $rd, $rs1, $shamt",			def : InstAlias<"srl $rd, $rs1, $shamt",
                (SRLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt	                (SRLI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt
def : InstAlias<"sra $rd, $rs1, $shamt",			def : InstAlias<"sra $rd, $rs1, $shamt",
                (SRAI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt	                (SRAI  GPR:$rd, GPR:$rs1, uimmlog2xlen:$shamt
let Predicates = [IsRV64] in {					let Predicates = [IsRV64] in {
def : InstAlias<"addw $rd, $rs1, $imm12",			def : InstAlias<"addw $rd, $rs1, $imm12",
                (ADDIW  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (ADDIW  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"sllw $rd, $rs1, $shamt",			def : InstAlias<"sllw $rd, $rs1, $shamt",
                (SLLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;	                (SLLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
def : InstAlias<"srlw $rd, $rs1, $shamt",			def : InstAlias<"srlw $rd, $rs1, $shamt",
                (SRLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;	                (SRLIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
def : InstAlias<"sraw $rd, $rs1, $shamt",			def : InstAlias<"sraw $rd, $rs1, $shamt",
                (SRAIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;	                (SRAIW  GPR:$rd, GPR:$rs1, uimm5:$shamt)>;
} // Predicates = [IsRV64]					} // Predicates = [IsRV64]
def : InstAlias<"slt $rd, $rs1, $imm12",			def : InstAlias<"slt $rd, $rs1, $imm12",
                (SLTI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (SLTI  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
def : InstAlias<"sltu $rd, $rs1, $imm12",			def : InstAlias<"sltu $rd, $rs1, $imm12",
                (SLTIU  GPR:$rd, GPR:$rs1, simm12:$imm12)>;	                (SLTIU  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
}								}

def : MnemonicAlias<"move", "mv">;				def : MnemonicAlias<"move", "mv">;

// The SCALL and SBREAK instructions wererenamed to ECALL and	// The SCALL and SBREAK instructions wererenamed to ECALL and
// version 2.1 of the user-level ISA. Like the GNU toolchain,	// version 2.1 of the user-level ISA. Like the GNU toolchain,
// the old name for backwards compatibility.			// the old name for backwards compatibility.
def : MnemonicAlias<"scall", "ecall">;				def : MnemonicAlias<"scall", "ecall">;
def : MnemonicAlias<"sbreak", "ebreak">;			def : MnemonicAlias<"sbreak", "ebreak">;

//===--------------------------------------------------------	//===--------------------------------------------------------
// Pseudo-instructions and codegen patterns			// Pseudo-instructions and codegen patterns
//								//
// Naming convention: For 'generic' pattern classes, we use t	// Naming convention: For 'generic' pattern classes, we use t
// convention PatTy1Ty2. For pattern classes which offer a mo	// convention PatTy1Ty2. For pattern classes which offer a mo
// expension, prefix the class name, e.g. BccPat.		// expension, prefix the class name, e.g. BccPat.
//===--------------------------------------------------------	//===--------------------------------------------------------

/// Generic pattern classes					/// Generic pattern classes

class PatGprGpr<SDPatternOperator OpNode, RVInst Inst>		class PatGprGpr<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode GPR:$rs1, GPR:$rs2), (Inst GPR:$rs1, GPR:$r	    : Pat<(OpNode GPR:$rs1, GPR:$rs2), (Inst GPR:$rs1, GPR:$r
class PatGprSimm12<SDPatternOperator OpNode, RVInstI Inst>	class PatGprSimm12<SDPatternOperator OpNode, RVInstI Inst>
    : Pat<(OpNode GPR:$rs1, simm12:$imm12), (Inst GPR:$rs1, s	    : Pat<(OpNode GPR:$rs1, simm12:$imm12), (Inst GPR:$rs1, s
class PatGprUimmLog2XLen<SDPatternOperator OpNode, RVInstIShi	class PatGprUimmLog2XLen<SDPatternOperator OpNode, RVInstIShi
    : Pat<(OpNode GPR:$rs1, uimmlog2xlen:$shamt),		    : Pat<(OpNode GPR:$rs1, uimmlog2xlen:$shamt),
          (Inst GPR:$rs1, uimmlog2xlen:$shamt)>;		          (Inst GPR:$rs1, uimmlog2xlen:$shamt)>;

/// Predicates							/// Predicates

def IsOrAdd: PatFrag<(ops node:$A, node:$B), (or node:$A, nod	def IsOrAdd: PatFrag<(ops node:$A, node:$B), (or node:$A, nod
  return isOrEquivalentToAdd(N);				  return isOrEquivalentToAdd(N);
}]>;								}]>;
def assertsexti32 : PatFrag<(ops node:$src), (assertsext node	def assertsexti32 : PatFrag<(ops node:$src), (assertsext node
  return cast<VTSDNode>(N->getOperand(1))->getVT() == MVT::i3	  return cast<VTSDNode>(N->getOperand(1))->getVT() == MVT::i3
}]>;								}]>;
def sexti32 : PatFrags<(ops node:$src),				def sexti32 : PatFrags<(ops node:$src),
                       [(sext_inreg node:$src, i32),		                       [(sext_inreg node:$src, i32),
                        (assertsexti32 node:$src)]>;		                        (assertsexti32 node:$src)]>;
def assertzexti32 : PatFrag<(ops node:$src), (assertzext node	def assertzexti32 : PatFrag<(ops node:$src), (assertzext node
  return cast<VTSDNode>(N->getOperand(1))->getVT() == MVT::i3	  return cast<VTSDNode>(N->getOperand(1))->getVT() == MVT::i3
}]>;								}]>;
def assertzexti5 : PatFrag<(ops node:$src), (assertzext node:	def assertzexti5 : PatFrag<(ops node:$src), (assertzext node:
  return cast<VTSDNode>(N->getOperand(1))->getVT().getSizeInB	  return cast<VTSDNode>(N->getOperand(1))->getVT().getSizeInB
}]>;								}]>;
def zexti32 : PatFrags<(ops node:$src),				def zexti32 : PatFrags<(ops node:$src),
                       [(and node:$src, 0xffffffff),		                       [(and node:$src, 0xffffffff),
                        (assertzexti32 node:$src)]>;		                        (assertzexti32 node:$src)]>;
// Defines a legal mask for (assertzexti5 (and src, mask)) to	// Defines a legal mask for (assertzexti5 (and src, mask)) to
// with a shiftw operation. The mask mustn't modify the lower	// with a shiftw operation. The mask mustn't modify the lower
// upper 32 bits.						// upper 32 bits.
def shiftwamt_mask : ImmLeaf<XLenVT, [{				def shiftwamt_mask : ImmLeaf<XLenVT, [{
  return countTrailingOnes<uint64_t>(Imm) >= 5 && isUInt<32>(	  return countTrailingOnes<uint64_t>(Imm) >= 5 && isUInt<32>(
}]>;								}]>;
def shiftwamt : PatFrags<(ops node:$src),			def shiftwamt : PatFrags<(ops node:$src),
                         [(assertzexti5 (and node:$src, shift	                         [(assertzexti5 (and node:$src, shift
                          (assertzexti5 node:$src)]>;		                          (assertzexti5 node:$src)]>;

/// Immediates							/// Immediates

def : Pat<(simm12:$imm), (ADDI X0, simm12:$imm)>;		def : Pat<(simm12:$imm), (ADDI X0, simm12:$imm)>;
def : Pat<(simm32hi20:$imm), (LUI (HI20 imm:$imm))>;		def : Pat<(simm32hi20:$imm), (LUI (HI20 imm:$imm))>;
def : Pat<(simm32:$imm), (ADDI (LUI (HI20 imm:$imm)), (LO12Se	def : Pat<(simm32:$imm), (ADDI (LUI (HI20 imm:$imm)), (LO12Se
      Requires<[IsRV32]>;					      Requires<[IsRV32]>;

/// Simple arithmetic operations				/// Simple arithmetic operations

def : PatGprGpr<add, ADD>;					def : PatGprGpr<add, ADD>;
def : PatGprSimm12<add, ADDI>;					def : PatGprSimm12<add, ADDI>;
def : PatGprGpr<sub, SUB>;					def : PatGprGpr<sub, SUB>;
def : PatGprGpr<or, OR>;					def : PatGprGpr<or, OR>;
def : PatGprSimm12<or, ORI>;					def : PatGprSimm12<or, ORI>;
def : PatGprGpr<and, AND>;					def : PatGprGpr<and, AND>;
def : PatGprSimm12<and, ANDI>;					def : PatGprSimm12<and, ANDI>;
def : PatGprGpr<xor, XOR>;					def : PatGprGpr<xor, XOR>;
def : PatGprSimm12<xor, XORI>;					def : PatGprSimm12<xor, XORI>;
def : PatGprUimmLog2XLen<shl, SLLI>;				def : PatGprUimmLog2XLen<shl, SLLI>;
def : PatGprUimmLog2XLen<srl, SRLI>;				def : PatGprUimmLog2XLen<srl, SRLI>;
def : PatGprUimmLog2XLen<sra, SRAI>;				def : PatGprUimmLog2XLen<sra, SRAI>;

							      >
							      >	def : PatGprGpr<ldw, LDW>;
							      >	def : PatGprGpr<sdw, SDW>;
							      >
// Match both a plain shift and one where the shift amount is	// Match both a plain shift and one where the shift amount is
// typically introduced when the legalizer promotes the shift	// typically introduced when the legalizer promotes the shift
// zero-extends it). For RISC-V, the mask is unnecessary as s	// zero-extends it). For RISC-V, the mask is unnecessary as s
// ISA only read the least significant 5 bits (RV32I) or 6 bi	// ISA only read the least significant 5 bits (RV32I) or 6 bi
class shiftop<SDPatternOperator operator>			class shiftop<SDPatternOperator operator>
    : PatFrags<(ops node:$val, node:$count),			    : PatFrags<(ops node:$val, node:$count),
               [(operator node:$val, node:$count),		               [(operator node:$val, node:$count),
                (operator node:$val, (and node:$count, immbot	                (operator node:$val, (and node:$count, immbot

def : PatGprGpr<shiftop<shl>, SLL>;				def : PatGprGpr<shiftop<shl>, SLL>;
def : PatGprGpr<shiftop<srl>, SRL>;				def : PatGprGpr<shiftop<srl>, SRL>;
def : PatGprGpr<shiftop<sra>, SRA>;				def : PatGprGpr<shiftop<sra>, SRA>;

/// FrameIndex calculations					/// FrameIndex calculations

def : Pat<(add (i32 AddrFI:$Rs), simm12:$imm12),		def : Pat<(add (i32 AddrFI:$Rs), simm12:$imm12),
          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;		          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;
def : Pat<(IsOrAdd (i32 AddrFI:$Rs), simm12:$imm12),		def : Pat<(IsOrAdd (i32 AddrFI:$Rs), simm12:$imm12),
          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;		          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;

/// Setcc							/// Setcc

def : PatGprGpr<setlt, SLT>;					def : PatGprGpr<setlt, SLT>;
def : PatGprSimm12<setlt, SLTI>;				def : PatGprSimm12<setlt, SLTI>;
def : PatGprGpr<setult, SLTU>;					def : PatGprGpr<setult, SLTU>;
def : PatGprSimm12<setult, SLTIU>;				def : PatGprSimm12<setult, SLTIU>;

// Define pattern expansions for setcc operations that aren't	// Define pattern expansions for setcc operations that aren't
// handled by a RISC-V instruction.				// handled by a RISC-V instruction.
def : Pat<(seteq GPR:$rs1, 0), (SLTIU GPR:$rs1, 1)>;		def : Pat<(seteq GPR:$rs1, 0), (SLTIU GPR:$rs1, 1)>;
def : Pat<(seteq GPR:$rs1, GPR:$rs2), (SLTIU (XOR GPR:$rs1, G	def : Pat<(seteq GPR:$rs1, GPR:$rs2), (SLTIU (XOR GPR:$rs1, G
def : Pat<(setne GPR:$rs1, 0), (SLTU X0, GPR:$rs1)>;		def : Pat<(setne GPR:$rs1, 0), (SLTU X0, GPR:$rs1)>;
def : Pat<(setne GPR:$rs1, GPR:$rs2), (SLTU X0, (XOR GPR:$rs1	def : Pat<(setne GPR:$rs1, GPR:$rs2), (SLTU X0, (XOR GPR:$rs1
def : Pat<(setugt GPR:$rs1, GPR:$rs2), (SLTU GPR:$rs2, GPR:$r	def : Pat<(setugt GPR:$rs1, GPR:$rs2), (SLTU GPR:$rs2, GPR:$r
def : Pat<(setuge GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs1, 	def : Pat<(setuge GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs1, 
def : Pat<(setule GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs2, 	def : Pat<(setule GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs2, 
def : Pat<(setgt GPR:$rs1, GPR:$rs2), (SLT GPR:$rs2, GPR:$rs1	def : Pat<(setgt GPR:$rs1, GPR:$rs2), (SLT GPR:$rs2, GPR:$rs1
def : Pat<(setge GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs1, GP	def : Pat<(setge GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs1, GP
def : Pat<(setle GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs2, GP	def : Pat<(setle GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs2, GP

let usesCustomInserter = 1 in					let usesCustomInserter = 1 in
class SelectCC_rrirr<RegisterClass valty, RegisterClass cmpty	class SelectCC_rrirr<RegisterClass valty, RegisterClass cmpty
    : Pseudo<(outs valty:$dst),					    : Pseudo<(outs valty:$dst),
             (ins cmpty:$lhs, cmpty:$rhs, ixlenimm:$imm,	             (ins cmpty:$lhs, cmpty:$rhs, ixlenimm:$imm,
              valty:$truev, valty:$falsev),			              valty:$truev, valty:$falsev),
             [(set valty:$dst, (SelectCC cmpty:$lhs, cmpty:$r	             [(set valty:$dst, (SelectCC cmpty:$lhs, cmpty:$r
              (XLenVT imm:$imm), valty:$truev, valty:$falsev)	              (XLenVT imm:$imm), valty:$truev, valty:$falsev)

def Select_GPR_Using_CC_GPR : SelectCC_rrirr<GPR, GPR>;		def Select_GPR_Using_CC_GPR : SelectCC_rrirr<GPR, GPR>;

/// Branches and jumps						/// Branches and jumps

// Match `(brcond (CondOp ..), ..)` and lower to the appropri	// Match `(brcond (CondOp ..), ..)` and lower to the appropri
// instruction.							// instruction.
class BccPat<PatFrag CondOp, RVInstB Inst>			class BccPat<PatFrag CondOp, RVInstB Inst>
    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$i	    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$i
          (Inst GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12)>;	          (Inst GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12)>;

def : BccPat<seteq, BEQ>;					def : BccPat<seteq, BEQ>;
def : BccPat<setne, BNE>;					def : BccPat<setne, BNE>;
def : BccPat<setlt, BLT>;					def : BccPat<setlt, BLT>;
def : BccPat<setge, BGE>;					def : BccPat<setge, BGE>;
def : BccPat<setult, BLTU>;					def : BccPat<setult, BLTU>;
def : BccPat<setuge, BGEU>;					def : BccPat<setuge, BGEU>;

class BccSwapPat<PatFrag CondOp, RVInst InstBcc>		class BccSwapPat<PatFrag CondOp, RVInst InstBcc>
    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$i	    : Pat<(brcond (XLenVT (CondOp GPR:$rs1, GPR:$rs2)), bb:$i
          (InstBcc GPR:$rs2, GPR:$rs1, bb:$imm12)>;		          (InstBcc GPR:$rs2, GPR:$rs1, bb:$imm12)>;

// Condition codes that don't have matching RISC-V branch ins	// Condition codes that don't have matching RISC-V branch ins
// are trivially supported by swapping the two input operands	// are trivially supported by swapping the two input operands
def : BccSwapPat<setgt, BLT>;					def : BccSwapPat<setgt, BLT>;
def : BccSwapPat<setle, BGE>;					def : BccSwapPat<setle, BGE>;
def : BccSwapPat<setugt, BLTU>;					def : BccSwapPat<setugt, BLTU>;
def : BccSwapPat<setule, BGEU>;					def : BccSwapPat<setule, BGEU>;

// An extra pattern is needed for a brcond without a setcc (i	// An extra pattern is needed for a brcond without a setcc (i
// condition was calculated elsewhere).				// condition was calculated elsewhere).
def : Pat<(brcond GPR:$cond, bb:$imm12), (BNE GPR:$cond, X0, 	def : Pat<(brcond GPR:$cond, bb:$imm12), (BNE GPR:$cond, X0, 

let isBarrier = 1, isBranch = 1, isTerminator = 1 in		let isBarrier = 1, isBranch = 1, isTerminator = 1 in
def PseudoBR : Pseudo<(outs), (ins simm21_lsb0_jal:$imm20), [	def PseudoBR : Pseudo<(outs), (ins simm21_lsb0_jal:$imm20), [
               PseudoInstExpansion<(JAL X0, simm21_lsb0_jal:$	               PseudoInstExpansion<(JAL X0, simm21_lsb0_jal:$

let isCall = 1, Defs=[X1] in					let isCall = 1, Defs=[X1] in
let isBarrier = 1, isBranch = 1, isIndirectBranch = 1, isTerm	let isBarrier = 1, isBranch = 1, isIndirectBranch = 1, isTerm
def PseudoBRIND : Pseudo<(outs), (ins GPR:$rs1, simm12:$imm12	def PseudoBRIND : Pseudo<(outs), (ins GPR:$rs1, simm12:$imm12
                  PseudoInstExpansion<(JALR X0, GPR:$rs1, sim	                  PseudoInstExpansion<(JALR X0, GPR:$rs1, sim

def : Pat<(brind GPR:$rs1), (PseudoBRIND GPR:$rs1, 0)>;		def : Pat<(brind GPR:$rs1), (PseudoBRIND GPR:$rs1, 0)>;
def : Pat<(brind (add GPR:$rs1, simm12:$imm12)),		def : Pat<(brind (add GPR:$rs1, simm12:$imm12)),
          (PseudoBRIND GPR:$rs1, simm12:$imm12)>;		          (PseudoBRIND GPR:$rs1, simm12:$imm12)>;

// PseudoCALL is a pseudo instruction which will eventually e	// PseudoCALL is a pseudo instruction which will eventually e
// and jalr while encoding. This is desirable, as an auipc+ja	// and jalr while encoding. This is desirable, as an auipc+ja
// R_RISCV_CALL and R_RISCV_RELAX relocations can be be relax	// R_RISCV_CALL and R_RISCV_RELAX relocations can be be relax
// if the offset fits in a signed 21-bit immediate.		// if the offset fits in a signed 21-bit immediate.
// Define AsmString to print "call" when compile with -S flag	// Define AsmString to print "call" when compile with -S flag
// Define isCodeGenOnly = 0 to support parsing assembly "call	// Define isCodeGenOnly = 0 to support parsing assembly "call
let isCall = 1, Defs = [X1], isCodeGenOnly = 0 in		let isCall = 1, Defs = [X1], isCodeGenOnly = 0 in
def PseudoCALL : Pseudo<(outs), (ins bare_symbol:$func),	def PseudoCALL : Pseudo<(outs), (ins bare_symbol:$func),
                        [(Call tglobaladdr:$func)]> {		                        [(Call tglobaladdr:$func)]> {
  let AsmString = "call\t$func";				  let AsmString = "call\t$func";
}								}

def : Pat<(Call texternalsym:$func), (PseudoCALL texternalsym	def : Pat<(Call texternalsym:$func), (PseudoCALL texternalsym

def : Pat<(URetFlag), (URET X0, X0)>;				def : Pat<(URetFlag), (URET X0, X0)>;
def : Pat<(SRetFlag), (SRET X0, X0)>;				def : Pat<(SRetFlag), (SRET X0, X0)>;
def : Pat<(MRetFlag), (MRET X0, X0)>;				def : Pat<(MRetFlag), (MRET X0, X0)>;

let isCall = 1, Defs = [X1] in					let isCall = 1, Defs = [X1] in
def PseudoCALLIndirect : Pseudo<(outs), (ins GPR:$rs1), [(Cal	def PseudoCALLIndirect : Pseudo<(outs), (ins GPR:$rs1), [(Cal
                         PseudoInstExpansion<(JALR X1, GPR:$r	                         PseudoInstExpansion<(JALR X1, GPR:$r

let isBarrier = 1, isReturn = 1, isTerminator = 1 in		let isBarrier = 1, isReturn = 1, isTerminator = 1 in
def PseudoRET : Pseudo<(outs), (ins), [(RetFlag)]>,		def PseudoRET : Pseudo<(outs), (ins), [(RetFlag)]>,
                PseudoInstExpansion<(JALR X0, X1, 0)>;		                PseudoInstExpansion<(JALR X0, X1, 0)>;

// PseudoTAIL is a pseudo instruction similar to PseudoCALL a	// PseudoTAIL is a pseudo instruction similar to PseudoCALL a
// expand to auipc and jalr while encoding.			// expand to auipc and jalr while encoding.
// Define AsmString to print "tail" when compile with -S flag	// Define AsmString to print "tail" when compile with -S flag
let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1	let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1
    isCodeGenOnly = 0 in					    isCodeGenOnly = 0 in
def PseudoTAIL : Pseudo<(outs), (ins bare_symbol:$dst), []> {	def PseudoTAIL : Pseudo<(outs), (ins bare_symbol:$dst), []> {
  let AsmString = "tail\t$dst";					  let AsmString = "tail\t$dst";
}								}

let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1	let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1
def PseudoTAILIndirect : Pseudo<(outs), (ins GPRTC:$rs1), [(T	def PseudoTAILIndirect : Pseudo<(outs), (ins GPRTC:$rs1), [(T
                         PseudoInstExpansion<(JALR X0, GPR:$r	                         PseudoInstExpansion<(JALR X0, GPR:$r

def : Pat<(Tail (iPTR tglobaladdr:$dst)),			def : Pat<(Tail (iPTR tglobaladdr:$dst)),
          (PseudoTAIL texternalsym:$dst)>;			          (PseudoTAIL texternalsym:$dst)>;
def : Pat<(Tail (iPTR texternalsym:$dst)),			def : Pat<(Tail (iPTR texternalsym:$dst)),
          (PseudoTAIL texternalsym:$dst)>;			          (PseudoTAIL texternalsym:$dst)>;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0, isCodeGenO	let hasSideEffects = 0, mayLoad = 0, mayStore = 0, isCodeGenO
    isAsmParserOnly = 1 in					    isAsmParserOnly = 1 in
def PseudoLLA : Pseudo<(outs GPR:$dst), (ins bare_symbol:$src	def PseudoLLA : Pseudo<(outs GPR:$dst), (ins bare_symbol:$src
                       "lla", "$dst, $src">;			                       "lla", "$dst, $src">;

/// Loads							/// Loads

multiclass LdPat<PatFrag LoadOp, RVInst Inst> {			multiclass LdPat<PatFrag LoadOp, RVInst Inst> {
  def : Pat<(LoadOp GPR:$rs1), (Inst GPR:$rs1, 0)>;		  def : Pat<(LoadOp GPR:$rs1), (Inst GPR:$rs1, 0)>;
  def : Pat<(LoadOp AddrFI:$rs1), (Inst AddrFI:$rs1, 0)>;	  def : Pat<(LoadOp AddrFI:$rs1), (Inst AddrFI:$rs1, 0)>;
  def : Pat<(LoadOp (add GPR:$rs1, simm12:$imm12)),		  def : Pat<(LoadOp (add GPR:$rs1, simm12:$imm12)),
            (Inst GPR:$rs1, simm12:$imm12)>;			            (Inst GPR:$rs1, simm12:$imm12)>;
  def : Pat<(LoadOp (add AddrFI:$rs1, simm12:$imm12)),		  def : Pat<(LoadOp (add AddrFI:$rs1, simm12:$imm12)),
            (Inst AddrFI:$rs1, simm12:$imm12)>;			            (Inst AddrFI:$rs1, simm12:$imm12)>;
  def : Pat<(LoadOp (IsOrAdd AddrFI:$rs1, simm12:$imm12)),	  def : Pat<(LoadOp (IsOrAdd AddrFI:$rs1, simm12:$imm12)),
            (Inst AddrFI:$rs1, simm12:$imm12)>;			            (Inst AddrFI:$rs1, simm12:$imm12)>;
}								}

defm : LdPat<sextloadi8, LB>;					defm : LdPat<sextloadi8, LB>;
defm : LdPat<extloadi8, LB>;					defm : LdPat<extloadi8, LB>;
defm : LdPat<sextloadi16, LH>;					defm : LdPat<sextloadi16, LH>;
defm : LdPat<extloadi16, LH>;					defm : LdPat<extloadi16, LH>;
defm : LdPat<load, LW>, Requires<[IsRV32]>;			defm : LdPat<load, LW>, Requires<[IsRV32]>;
defm : LdPat<zextloadi8, LBU>;					defm : LdPat<zextloadi8, LBU>;
defm : LdPat<zextloadi16, LHU>;					defm : LdPat<zextloadi16, LHU>;

							      >
							      >	/// def LWD : PatFrag<
							      >	/// 	(LoadOp GPR:$rs1),
							      >	/// 	(LWD GPR:$rs3, GPR:$rs1, GPR:$rs2),
							      >	/// 	[{return cast<MemSDNode>(N)->getAddressSpace() == 1}]
							      >	/// >; 
							      >
/// Stores							/// Stores

multiclass StPat<PatFrag StoreOp, RVInst Inst, RegisterClass 	multiclass StPat<PatFrag StoreOp, RVInst Inst, RegisterClass 
  def : Pat<(StoreOp StTy:$rs2, GPR:$rs1), (Inst StTy:$rs2, G	  def : Pat<(StoreOp StTy:$rs2, GPR:$rs1), (Inst StTy:$rs2, G
  def : Pat<(StoreOp StTy:$rs2, AddrFI:$rs1), (Inst StTy:$rs2	  def : Pat<(StoreOp StTy:$rs2, AddrFI:$rs1), (Inst StTy:$rs2
  def : Pat<(StoreOp StTy:$rs2, (add GPR:$rs1, simm12:$imm12)	  def : Pat<(StoreOp StTy:$rs2, (add GPR:$rs1, simm12:$imm12)
            (Inst StTy:$rs2, GPR:$rs1, simm12:$imm12)>;		            (Inst StTy:$rs2, GPR:$rs1, simm12:$imm12)>;
  def : Pat<(StoreOp StTy:$rs2, (add AddrFI:$rs1, simm12:$imm	  def : Pat<(StoreOp StTy:$rs2, (add AddrFI:$rs1, simm12:$imm
            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;	            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
  def : Pat<(StoreOp StTy:$rs2, (IsOrAdd AddrFI:$rs1, simm12:	  def : Pat<(StoreOp StTy:$rs2, (IsOrAdd AddrFI:$rs1, simm12:
            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;	            (Inst StTy:$rs2, AddrFI:$rs1, simm12:$imm12)>;
}								}

defm : StPat<truncstorei8, SB, GPR>;				defm : StPat<truncstorei8, SB, GPR>;
defm : StPat<truncstorei16, SH, GPR>;				defm : StPat<truncstorei16, SH, GPR>;
defm : StPat<store, SW, GPR>, Requires<[IsRV32]>;		defm : StPat<store, SW, GPR>, Requires<[IsRV32]>;
							      >
							      >	///	def SWD : PatFrag<
							      >	///		(StoreOp StTy:$rs3, GPR:$rs1),
							      >	///		(SWD StTy:$rs3, GPR:$rs1, GPR:$rs2),
							      >	///		[{return cast<MemSDNode>(N)->getAddressSpace(
							      >	///	>;

/// Fences							/// Fences

// Refer to Table A.6 in the version 2.3 draft of the RISC-V 	// Refer to Table A.6 in the version 2.3 draft of the RISC-V 
// Manual: Volume I.						// Manual: Volume I.

// fence acquire -> fence r, rw					// fence acquire -> fence r, rw
def : Pat<(atomic_fence (XLenVT 4), (imm)), (FENCE 0b10, 0b11	def : Pat<(atomic_fence (XLenVT 4), (imm)), (FENCE 0b10, 0b11
// fence release -> fence rw, w					// fence release -> fence rw, w
def : Pat<(atomic_fence (XLenVT 5), (imm)), (FENCE 0b11, 0b1)	def : Pat<(atomic_fence (XLenVT 5), (imm)), (FENCE 0b11, 0b1)
// fence acq_rel -> fence.tso					// fence acq_rel -> fence.tso
def : Pat<(atomic_fence (XLenVT 6), (imm)), (FENCE_TSO)>;	def : Pat<(atomic_fence (XLenVT 6), (imm)), (FENCE_TSO)>;
// fence seq_cst -> fence rw, rw				// fence seq_cst -> fence rw, rw
def : Pat<(atomic_fence (XLenVT 7), (imm)), (FENCE 0b11, 0b11	def : Pat<(atomic_fence (XLenVT 7), (imm)), (FENCE 0b11, 0b11

// Lowering for atomic load and store is defined in RISCVInst	// Lowering for atomic load and store is defined in RISCVInst
// Although these are lowered to fence+load/store instruction	// Although these are lowered to fence+load/store instruction
// base RV32I/RV64I ISA, this lowering is only used when the 	// base RV32I/RV64I ISA, this lowering is only used when the 
// present. This is necessary as it isn't valid to mix __atom	// present. This is necessary as it isn't valid to mix __atom
// with inline atomic operations for the same object.		// with inline atomic operations for the same object.

/// Other pseudo-instructions					/// Other pseudo-instructions

// Pessimistically assume the stack pointer will be clobbered	// Pessimistically assume the stack pointer will be clobbered
let Defs = [X2], Uses = [X2] in {				let Defs = [X2], Uses = [X2] in {
def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt1, i32i	def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt1, i32i
                              [(CallSeqStart timm:$amt1, timm	                              [(CallSeqStart timm:$amt1, timm
def ADJCALLSTACKUP   : Pseudo<(outs), (ins i32imm:$amt1, i32i	def ADJCALLSTACKUP   : Pseudo<(outs), (ins i32imm:$amt1, i32i
                              [(CallSeqEnd timm:$amt1, timm:$	                              [(CallSeqEnd timm:$amt1, timm:$
} // Defs = [X2], Uses = [X2]					} // Defs = [X2], Uses = [X2]

/// RV64 patterns						/// RV64 patterns

let Predicates = [IsRV64] in {					let Predicates = [IsRV64] in {

/// sext and zext						/// sext and zext

def : Pat<(sext_inreg GPR:$rs1, i32), (ADDIW GPR:$rs1, 0)>;	def : Pat<(sext_inreg GPR:$rs1, i32), (ADDIW GPR:$rs1, 0)>;
def : Pat<(and GPR:$rs1, 0xffffffff), (SRLI (SLLI GPR:$rs1, 3	def : Pat<(and GPR:$rs1, 0xffffffff), (SRLI (SLLI GPR:$rs1, 3

/// ALU operations						/// ALU operations

def : Pat<(sext_inreg (add GPR:$rs1, GPR:$rs2), i32),		def : Pat<(sext_inreg (add GPR:$rs1, GPR:$rs2), i32),
          (ADDW GPR:$rs1, GPR:$rs2)>;				          (ADDW GPR:$rs1, GPR:$rs2)>;
def : Pat<(sext_inreg (add GPR:$rs1, simm12:$imm12), i32),	def : Pat<(sext_inreg (add GPR:$rs1, simm12:$imm12), i32),
          (ADDIW GPR:$rs1, simm12:$imm12)>;			          (ADDIW GPR:$rs1, simm12:$imm12)>;
def : Pat<(sext_inreg (sub GPR:$rs1, GPR:$rs2), i32),		def : Pat<(sext_inreg (sub GPR:$rs1, GPR:$rs2), i32),
          (SUBW GPR:$rs1, GPR:$rs2)>;				          (SUBW GPR:$rs1, GPR:$rs2)>;
def : Pat<(sext_inreg (shl GPR:$rs1, uimm5:$shamt), i32),	def : Pat<(sext_inreg (shl GPR:$rs1, uimm5:$shamt), i32),
          (SLLIW GPR:$rs1, uimm5:$shamt)>;			          (SLLIW GPR:$rs1, uimm5:$shamt)>;
// (srl (zexti32 ...), uimm5:$shamt) is matched with custom c	// (srl (zexti32 ...), uimm5:$shamt) is matched with custom c
// need to undo manipulation of the mask value performed by D	// need to undo manipulation of the mask value performed by D
def : Pat<(sra (sext_inreg GPR:$rs1, i32), uimm5:$shamt),	def : Pat<(sra (sext_inreg GPR:$rs1, i32), uimm5:$shamt),
          (SRAIW GPR:$rs1, uimm5:$shamt)>;			          (SRAIW GPR:$rs1, uimm5:$shamt)>;

// For variable-length shifts, we rely on assertzexti5 being 	// For variable-length shifts, we rely on assertzexti5 being 
// lowering (see RISCVTargetLowering::PerformDAGCombine). Thi	// lowering (see RISCVTargetLowering::PerformDAGCombine). Thi
// guarantee that selecting a 32-bit variable shift is legal 	// guarantee that selecting a 32-bit variable shift is legal 
// shift is known to be <= 32). We must also be careful not t	// shift is known to be <= 32). We must also be careful not t
// semantically incorrect patterns. For instance, selecting S	// semantically incorrect patterns. For instance, selecting S
// (srl (zexti32 GPR:$rs1), (shiftwamt GPR:$rs2)),		// (srl (zexti32 GPR:$rs1), (shiftwamt GPR:$rs2)),
// is not guaranteed to be safe, as we don't know whether the	// is not guaranteed to be safe, as we don't know whether the
// the result are used or not (in the case where rs2=0, this 	// the result are used or not (in the case where rs2=0, this 
// sign-extension operation).					// sign-extension operation).

def : Pat<(sext_inreg (shl GPR:$rs1, (shiftwamt GPR:$rs2)), i	def : Pat<(sext_inreg (shl GPR:$rs1, (shiftwamt GPR:$rs2)), i
          (SLLW GPR:$rs1, GPR:$rs2)>;				          (SLLW GPR:$rs1, GPR:$rs2)>;
def : Pat<(zexti32 (shl GPR:$rs1, (shiftwamt GPR:$rs2))),	def : Pat<(zexti32 (shl GPR:$rs1, (shiftwamt GPR:$rs2))),
          (SRLI (SLLI (SLLW GPR:$rs1, GPR:$rs2), 32), 32)>;	          (SRLI (SLLI (SLLW GPR:$rs1, GPR:$rs2), 32), 32)>;

def : Pat<(sext_inreg (srl (zexti32 GPR:$rs1), (shiftwamt GPR	def : Pat<(sext_inreg (srl (zexti32 GPR:$rs1), (shiftwamt GPR
          (SRLW GPR:$rs1, GPR:$rs2)>;				          (SRLW GPR:$rs1, GPR:$rs2)>;
def : Pat<(zexti32 (srl (zexti32 GPR:$rs1), (shiftwamt GPR:$r	def : Pat<(zexti32 (srl (zexti32 GPR:$rs1), (shiftwamt GPR:$r
          (SRLI (SLLI (SRLW GPR:$rs1, GPR:$rs2), 32), 32)>;	          (SRLI (SLLI (SRLW GPR:$rs1, GPR:$rs2), 32), 32)>;

def : Pat<(sra (sexti32 GPR:$rs1), (shiftwamt GPR:$rs2)),	def : Pat<(sra (sexti32 GPR:$rs1), (shiftwamt GPR:$rs2)),
          (SRAW GPR:$rs1, GPR:$rs2)>;				          (SRAW GPR:$rs1, GPR:$rs2)>;

/// Loads							/// Loads

defm : LdPat<sextloadi32, LW>;					defm : LdPat<sextloadi32, LW>;
defm : LdPat<extloadi32, LW>;					defm : LdPat<extloadi32, LW>;
defm : LdPat<zextloadi32, LWU>;					defm : LdPat<zextloadi32, LWU>;
defm : LdPat<load, LD>;						defm : LdPat<load, LD>;

/// Stores							/// Stores

defm : StPat<truncstorei32, SW, GPR>;				defm : StPat<truncstorei32, SW, GPR>;
defm : StPat<store, SD, GPR>;					defm : StPat<store, SD, GPR>;
} // Predicates = [IsRV64]					} // Predicates = [IsRV64]

//===--------------------------------------------------------	//===--------------------------------------------------------
// Standard extensions						// Standard extensions
//===--------------------------------------------------------	//===--------------------------------------------------------

include "RISCVInstrInfoM.td"					include "RISCVInstrInfoM.td"
include "RISCVInstrInfoA.td"					include "RISCVInstrInfoA.td"
include "RISCVInstrInfoF.td"					include "RISCVInstrInfoF.td"
include "RISCVInstrInfoD.td"					include "RISCVInstrInfoD.td"
include "RISCVInstrInfoC.td"					include "RISCVInstrInfoC.td"
